# need pip3 install kafka-python
import random
import time
import string
from json import dumps
from kafka import KafkaProducer

# configure argument parser
PARSER = argparse.ArgumentParser(description="A program that generates data similar to THR's data and writes it to a kafka topic", epilog="Thanks!")

PARSER.add_argument("-t", "--topic",     	 help="the name of the kafka topic to write to", default="thr")
PARSER.add_argument("-i", "--kafka-ip",   	 help="the IPv4 address of the host running kafka", default="localhost")
PARSER.add_argument("-p", "--kafka-port", 	 help="the port listening for kafka messages on the host running kafka", default="9092")
PARSER.add_argument("-u", "--unqiue-device-ids", help="the number of unique device ids", default="200000")

# parse args and store in dict()
ARGV = PARSER.parse_args()
argv = vars(ARGV)

# do some argument error handling here

# producer config
topic = argv['topic']
bootstrap_servers_ = [f'{argv["kafka_ip"]}:{argv["kafka_port"]}']
value_serializer_ = lambda x: dumps(x).encode('utf-8')
producer = KafkaProducer(bootstrap_servers=bootstrap_servers_, value_serializer=value_serializer_)

thrity_days = range(30*24*60*60)
event = ["PUT","POST","GET", "DELETE"]
device_id = segs = [''.join(random.choices(string.ascii_letters + string.digits, k=16)) for _ in range(argv["unique_device_ids"])]
bytes_sent = range(0,100_000)
severity = range(1,6)

def gen_record(r_type="current"):

	if r_type == "current":
		t = int(time.time())
	elif r_type == "past":
		t = int(time.time()) - random.choice(thrity_days)
	else:
		print("record type must be current or past")
		exit()

	e = random.choice(event)
	d = random.choice(device_id)
	b = random.choice(bytes_sent)
	s = random.choice(severity)
	log = f"this is a {e} event generated by device {d} at {t}. Size of the event was {b} bytes. Severity of the event was {s}"

	return {'e': e,'d': d,'b': b,'s': s,'t': t, 'log':log}

# record past
for _ in range(2_000_000):
	record = gen_record(r_type="past")
	future = producer.send(topic, record)
	result = future.get(timeout=60)
	producer.flush()

# record current
while(True):
	record = gen_record(r_type="current")
	future = producer.send(topic, record)
	result = future.get(timeout=60)
	producer.flush()
